[
  {
    "query": "SELECT name FROM pg_timezone_names",
    "rolname": "authenticator",
    "calls": 66,
    "mean_time": 277.476630439394,
    "min_time": 53.076972,
    "max_time": 4164.225419,
    "total_time": 18313.457609,
    "rows_read": 78804,
    "cache_hit_rate": "0",
    "prop_total_time": 55.087884132746154,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
    "rolname": "authenticator",
    "calls": 66,
    "mean_time": 26.3104525,
    "min_time": 18.289805,
    "max_time": 74.619894,
    "total_time": 1736.489865,
    "rows_read": 66,
    "cache_hit_rate": "99.9084750402025524",
    "prop_total_time": 5.223456679955231,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
    "rolname": "postgres",
    "calls": 33,
    "mean_time": 48.4175159090909,
    "min_time": 2.221682,
    "max_time": 301.024929,
    "total_time": 1597.778025,
    "rows_read": 2574,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 4.806203863315912,
    "index_advisor_result": null
  },
  {
    "query": "SELECT * FROM pgbouncer.get_auth($1)",
    "rolname": "pgbouncer",
    "calls": 2070,
    "mean_time": 0.748674446859903,
    "min_time": 0.074665,
    "max_time": 38.062297,
    "total_time": 1549.756105,
    "rows_read": 2070,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 4.661751296177966,
    "index_advisor_result": null
  },
  {
    "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 100cf2a3-abb6-451f-924c-a2725e166df8\n-- date: 2026-01-18T07:23:10.601Z",
    "rolname": "postgres",
    "calls": 13,
    "mean_time": 96.1563613846154,
    "min_time": 67.566478,
    "max_time": 137.226453,
    "total_time": 1250.032698,
    "rows_read": 1469,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 3.7601668619762205,
    "index_advisor_result": null
  },
  {
    "query": "CREATE DATABASE \"prisma_migrate_shadow_db_1934ba8f-084a-4a93-bf75-875f51c6b936\"",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 1124.756424,
    "min_time": 1124.756424,
    "max_time": 1124.756424,
    "total_time": 1124.756424,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 3.383328964183364,
    "index_advisor_result": null
  },
  {
    "query": "CREATE DATABASE \"prisma_migrate_shadow_db_d2c58a85-7ebb-412b-a362-c23b19fb956d\"",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 1105.522252,
    "min_time": 1105.522252,
    "max_time": 1105.522252,
    "total_time": 1105.522252,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 3.3254715207039522,
    "index_advisor_result": null
  },
  {
    "query": "CREATE DATABASE \"prisma_migrate_shadow_db_29baa325-9ef9-4d1c-bc43-e87cc049caee\"",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 897.051973,
    "min_time": 897.051973,
    "max_time": 897.051973,
    "total_time": 897.051973,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 2.6983814965334507,
    "index_advisor_result": null
  },
  {
    "query": "SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,\n       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (\n  SELECT a.atttypid\n  FROM pg_attribute AS a\n  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped\n  ORDER BY a.attnum\n)\n\nFROM pg_type AS t\nLEFT JOIN pg_type AS d ON t.typbasetype = d.oid\nLEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)\nWHERE (t.typrelid = $4)\nAND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",
    "rolname": "pgbouncer",
    "calls": 20,
    "mean_time": 44.7329057,
    "min_time": 4.497734,
    "max_time": 95.256394,
    "total_time": 894.658114,
    "rows_read": 4580,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 2.691180637469168,
    "index_advisor_result": null
  },
  {
    "query": "CREATE DATABASE \"prisma_migrate_shadow_db_5bbcb581-f1c9-4009-8f45-c6f36f2afc7a\"",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 713.840993,
    "min_time": 713.840993,
    "max_time": 713.840993,
    "total_time": 713.840993,
    "rows_read": 0,
    "cache_hit_rate": "40.2173913043478261",
    "prop_total_time": 2.1472728280574938,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
    "rolname": "authenticator",
    "calls": 66,
    "mean_time": 10.6534324090909,
    "min_time": 1.318049,
    "max_time": 69.982776,
    "total_time": 703.126539,
    "rows_read": 2831,
    "cache_hit_rate": "99.9226313698429626",
    "prop_total_time": 2.1150431632339832,
    "index_advisor_result": null
  },
  {
    "query": "SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,\n       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (\n  SELECT a.atttypid\n  FROM pg_attribute AS a\n  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped\n  ORDER BY a.attnum\n)\n\nFROM pg_type AS t\nLEFT JOIN pg_type AS d ON t.typbasetype = d.oid\nLEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)\nWHERE (t.typrelid = $4)\nAND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",
    "rolname": "supabase_admin",
    "calls": 17,
    "mean_time": 41.0322234705882,
    "min_time": 4.585998,
    "max_time": 115.843649,
    "total_time": 697.547799,
    "rows_read": 3913,
    "cache_hit_rate": "99.9977735723032395",
    "prop_total_time": 2.0982620075785006,
    "index_advisor_result": null
  },
  {
    "query": "DROP DATABASE IF EXISTS \"prisma_migrate_shadow_db_1934ba8f-084a-4a93-bf75-875f51c6b936\" WITH (FORCE)",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 601.45596,
    "min_time": 601.45596,
    "max_time": 601.45596,
    "total_time": 601.45596,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.809212489680086,
    "index_advisor_result": null
  },
  {
    "query": "SELECT p.proname AS name, n.nspname as namespace,\n                CASE WHEN l.lanname = $2 THEN p.prosrc\n                     ELSE pg_get_functiondef(p.oid)\n                     END as definition\n            FROM pg_proc p\n            LEFT JOIN pg_namespace n ON p.pronamespace = n.oid\n            LEFT JOIN pg_language l ON p.prolang = l.oid\n            WHERE n.nspname = ANY ( $1 )",
    "rolname": "postgres",
    "calls": 19,
    "mean_time": 21.3701237894737,
    "min_time": 0.496791,
    "max_time": 62.715097,
    "total_time": 406.032352,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.2213675668831698,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n                oid.namespace,\n                info.table_name,\n                info.column_name,\n                format_type(att.atttypid, att.atttypmod) as formatted_type,\n                info.numeric_precision,\n                info.numeric_scale,\n                info.numeric_precision_radix,\n                info.datetime_precision,\n                info.data_type,\n                info.udt_schema as type_schema_name,\n                info.udt_name as full_data_type,\n                pg_get_expr(attdef.adbin, attdef.adrelid) AS column_default,\n                info.is_nullable,\n                info.is_identity,\n                info.character_maximum_length,\n                col_description(att.attrelid, ordinal_position) AS description\n            FROM information_schema.columns info\n            JOIN pg_attribute att ON att.attname = info.column_name\n            JOIN (\n                 SELECT pg_class.oid, relname, pg_namespace.nspname as namespace\n                 FROM pg_class\n                 JOIN pg_namespace on pg_namespace.oid = pg_class.relnamespace\n                 AND pg_namespace.nspname = ANY ( $1 )\n                 WHERE reltype > $2\n                ) as oid on oid.oid = att.attrelid \n                  AND relname = info.table_name\n                  AND namespace = info.table_schema\n            LEFT OUTER JOIN pg_attrdef attdef ON attdef.adrelid = att.attrelid AND attdef.adnum = att.attnum AND table_schema = namespace\n            WHERE table_schema = ANY ( $1 ) \n            ORDER BY namespace, table_name, ordinal_position",
    "rolname": "postgres",
    "calls": 19,
    "mean_time": 21.3644874736842,
    "min_time": 0.245224,
    "max_time": 53.477427,
    "total_time": 405.925262,
    "rows_read": 2185,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.2210454342942436,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n                con.oid         AS \"con_id\",\n                att2.attname    AS \"child_column\",\n                cl.relname      AS \"parent_table\",\n                att.attname     AS \"parent_column\",\n                con.confdeltype,\n                con.confupdtype,\n                rel_ns.nspname  AS \"referenced_schema_name\",\n                conname         AS constraint_name,\n                child,\n                parent,\n                table_name, \n                namespace,\n                condeferrable,\n                condeferred\n            FROM (SELECT \n                        ns.nspname AS \"namespace\",\n                        unnest(con1.conkey)                AS \"parent\",\n                        unnest(con1.confkey)                AS \"child\",\n                        cl.relname                          AS table_name,\n                        ns.nspname                          AS schema_name,\n                        generate_subscripts(con1.conkey, $2) AS colidx,\n                        con1.oid,\n                        con1.confrelid,\n                        con1.conrelid,\n                        con1.conname,\n                        con1.confdeltype,\n                        con1.confupdtype,\n                        con1.condeferrable                  AS condeferrable,\n                        con1.condeferred                    AS condeferred\n                FROM pg_class cl\n                        join pg_constraint con1 on con1.conrelid = cl.oid\n                        join pg_namespace ns on cl.relnamespace = ns.oid\n                WHERE\n                    ns.nspname = ANY ( $1 )\n                    and con1.contype = $3\n                ORDER BY colidx\n                ) con\n                    JOIN pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child\n                    JOIN pg_class cl on cl.oid = con.confrelid\n                    JOIN pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent\n                    JOIN pg_class rel_cl on con.confrelid = rel_cl.oid\n                    JOIN pg_namespace rel_ns on rel_cl.relnamespace = rel_ns.oid\n            ORDER BY namespace, table_name, constraint_name, con_id, con.colidx",
    "rolname": "postgres",
    "calls": 19,
    "mean_time": 15.1287755263158,
    "min_time": 1.334089,
    "max_time": 56.651733,
    "total_time": 287.446735,
    "rows_read": 596,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.8646555320189394,
    "index_advisor_result": null
  },
  {
    "query": "DROP DATABASE IF EXISTS \"prisma_migrate_shadow_db_5bbcb581-f1c9-4009-8f45-c6f36f2afc7a\" WITH (FORCE)",
    "rolname": "postgres",
    "calls": 1,
    "mean_time": 264.246031,
    "min_time": 264.246031,
    "max_time": 264.246031,
    "total_time": 264.246031,
    "rows_read": 0,
    "cache_hit_rate": "94.9152542372881356",
    "prop_total_time": 0.7948665429029771,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
    "rolname": "supabase_auth_admin",
    "calls": 36,
    "mean_time": 6.54450519444444,
    "min_time": 0.213668,
    "max_time": 37.197421,
    "total_time": 235.602187,
    "rows_read": 36,
    "cache_hit_rate": "99.9654696132596685",
    "prop_total_time": 0.7087042903629107,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
    "rolname": "supabase_auth_admin",
    "calls": 45,
    "mean_time": 5.21650582222222,
    "min_time": 0.141898,
    "max_time": 34.01386,
    "total_time": 234.742762,
    "rows_read": 45,
    "cache_hit_rate": "99.9319264805990470",
    "prop_total_time": 0.7061190928632579,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
    "rolname": "postgres",
    "calls": 13,
    "mean_time": 17.2773447692308,
    "min_time": 8.062831,
    "max_time": 47.57829,
    "total_time": 224.605482,
    "rows_read": 817,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.6756255990630067,
    "index_advisor_result": null
  }
]
